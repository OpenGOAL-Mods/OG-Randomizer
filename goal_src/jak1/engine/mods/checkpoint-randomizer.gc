;;-*-Lisp-*-
(in-package goal)

;; name: checkpoint-randomizer.gc
;; name in dgo: checkpoint-randomizer
;; dgos: GAME, ENGINE

(define *checkpoint-list* (the-as (array string) (new
                                             'static
                                             'boxed-array
                                             :type string :length 77 :allocated-length 77
  "game-start"
  "training-far"
  "village1-hut"
  "village1-warp"
  "beach-start"
  "beach-pelican"
  "beach-far"
  "beach-start"
  "beach-pelican"
  "beach-far"
  "jungle-start"
  "jungle-far"
  "jungle-tower"
  "jungle-start"
  "jungle-far"
  "jungle-tower"
  "misty-start"
  "misty-silo"
  "misty-bike"
  "misty-backside"
  "misty-silo2"
  "firecanyon-start"
  "firecanyon-end"
  "village2-start"
  "village2-warp"
  "village2-dock"
  "sunken-start"
  "sunken1"
  "sunken2"
  "sunken-tube1"
  "sunkenb-start"
  "sunkenb-helix"
  "swamp-start"
  "swamp-dock1"
  "swamp-cave1"
  "swamp-dock2"
  "swamp-cave2"
  "swamp-game"
  "swamp-cave3"
  "swamp-flutflut"
  "rolling-start"
  "ogre-start"
  "ogre-race"
  "ogre-end"
  "village3-start"
  "village3-warp"
  "village3-farside"
  "village3-cart"
  "snow-start"
  "snow-fort"
  "snow-flut-flut"
  "snow-pass-to-fort"
  "snow-by-ice-lake"
  "snow-by-ice-lake-alt"
  "snow-outside-fort"
  "snow-outside-cave"
  "snow-across-from-flut"
  "maincave-start"
  "maincave-to-darkcave"
  "maincave-to-robocave"
  "darkcave-start"
  "robocave-start"
  "robocave-bottom"
  "lavatube-start"
  "lavatube-middle"
  "lavatube-after-ribbon"
  "lavatube-end"
  "citadel-start"
  "citadel-entrance"
  "citadel-warp"
  "citadel-plat-start"
  "citadel-plat-end"
  "citadel-launch-start"
  "citadel-launch-end"
  "citadel-generator-start"
  "citadel-generator-end"
  "citadel-elevator"
  )
  )
  )

(define *checkpoint-list-by-level-idx*
  (new 'static 'boxed-array :type (array string) :length 16 :allocated-length 16
    ;; Geyser Rock
    (new 'static 'boxed-array :type string :length 2
      "game-start"
      "training-far"
    )
    ;; Sandover
    (new 'static 'boxed-array :type string :length 3
      "village1-hut"
      "village1-warp"
      "village1-far"
    )
    ;; Sentinel Beach
    (new 'static 'boxed-array :type string :length 3
      "beach-start"
      "beach-pelican"
      "beach-far"
    )
    ;; Forbidden Jungle
    (new 'static 'boxed-array :type string :length 3
      "jungle-start"
      "jungle-far"
      "jungle-tower"
    )
    ;; Misty Island
    (new 'static 'boxed-array :type string :length 5
      "misty-start"
      "misty-silo"
      "misty-bike"
      "misty-backside"
      "misty-silo2"
    )
    ;; Fire Canyon
    (new 'static 'boxed-array :type string :length 2
      "firecanyon-start"
      "firecanyon-end"
    )
    ;; Rock Village
    (new 'static 'boxed-array :type string :length 3
      "village2-start"
      "village2-warp"
      "village2-dock"
    )
    ;; Lost Precursor City
    (new 'static 'boxed-array :type string :length 6
      "sunken-start"
      "sunken1"
      "sunken2"
      "sunken-tube1"
      "sunkenb-start"
      "sunkenb-helix"
    )
    ;; Boggy Swamp
    (new 'static 'boxed-array :type string :length 8
      "swamp-start"
      "swamp-dock1"
      "swamp-cave1"
      "swamp-dock2"
      "swamp-cave2"
      "swamp-game"
      "swamp-cave3"
      "swamp-flutflut"
    )
    ;; Precursor Basin
    (new 'static 'boxed-array :type string :length 1
      "rolling-start"
    )
    ;; Mountain Pass
    (new 'static 'boxed-array :type string :length 3
      "ogre-start"
      "ogre-race"
      "ogre-end"
    )
    ;; Volcanic Crater
    (new 'static 'boxed-array :type string :length 4
      "village3-start"
      "village3-warp"
      "village3-farside"
      "village3-cart"
    )
    ;; Snowy Mountain
    (new 'static 'boxed-array :type string :length 9
      "snow-start"
      "snow-fort"
      "snow-flut-flut"
      "snow-pass-to-fort"
      "snow-by-ice-lake"
      "snow-by-ice-lake-alt"
      "snow-outside-fort"
      "snow-outside-cave"
      "snow-across-from-flut"
    )
    ;; Spider Cave
    (new 'static 'boxed-array :type string :length 6
      "maincave-start"
      "maincave-to-darkcave"
      "maincave-to-robocave"
      "darkcave-start"
      "robocave-start"
      "robocave-bottom"
    )
    ;; Lava Tube
    (new 'static 'boxed-array :type string :length 6
      "lavatube-start"
      "lavatube-middle"
      "lavatube-after-ribbon"
      "lavatube-end"
      "citadel-entrance"
      "citadel-warp"
    )
    ;; Gol and Maia's Citadel
    (new 'static 'boxed-array :type string :length 8
      "citadel-start"
      "citadel-plat-start"
      "citadel-plat-end"
      "citadel-launch-start"
      "citadel-launch-end"
      "citadel-generator-start"
      "citadel-generator-end"
      "citadel-elevator"
    )
  )
)

(deftype rando-state (structure)
  (
    (next-idx int)
    (checkpoint-list (array string))
    (collectable-interval int) ;; serves as a counter, counts up until it reaches collectables-needed-to-warp, then resets back to 0
    (collectable-count int)
    )
  (:methods
    (new (symbol type int) _type_)
    )
  )

(defmethod new rando-state ((allocation symbol) (type-to-make type) (length int))
  "Allocate a new rando-state with a checkpoint list of given length"
  (let ((obj (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> obj next-idx) 0)
    (set! (-> obj checkpoint-list)
          (the-as (array string)
                  ((method-of-type array new) allocation array string length)
                  )
          )
    (set! (-> obj checkpoint-list length) 0)
    (set! (-> obj collectable-interval) 0)
    (set! (-> obj collectable-count) 0)
    obj
    )
  )

(define *rando-list-length* 1000)
(define *rando-state* (new 'global 'rando-state *rando-list-length*))

(defun update-collectable-hud-counters ()
  (when (and (-> *randomizer-settings* show-warp-counter?)
             (> (-> *rando-state* collectable-count) 0)
             (= *master-mode* 'game)
             (not (or (movie?) (< (-> *display* base-frame-counter) (-> *game-info* letterbox-time)))))
    (let ((str-x (the int (* 0.01 512)))
          (str-y (the int 60)))
      (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug))
        (draw-string-xy (string-format "~D/~D" (the int (-> *rando-state* collectable-interval)) (the int (-> *randomizer-settings* collectables-needed-to-warp)))
          buf str-x str-y (font-color white) (font-flags shadow kerning large))
        )
      )
    )
  )

(defun randomizer-run-each-frame ()
;;Randomizer stuff that needs to run constantly
(if (-> *randomizer-settings* checkpoint-randomizer?)
(begin

  ;;update the number of items they have collected
   (set! (-> *rando-state* collectable-count)
   (+
      (if (-> *randomizer-settings* warp-on-cell?) (the int (-> *game-info* fuel)) 0)
      (if (-> *randomizer-settings* warp-on-orb?) (the int (-> *game-info* money-total)) 0)
      (if (-> *randomizer-settings* warp-on-buzzer?) (the int (-> *game-info* buzzer-total)) 0)
      (if (-> *randomizer-settings* warp-on-green-eco?) (the int (-> *game-info* green-eco-total)) 0)
      (if (-> *randomizer-settings* warp-on-blue-eco?) (the int (-> *game-info* blue-eco-total)) 0)
      (if (-> *randomizer-settings* warp-on-red-eco?) (the int (-> *game-info* red-eco-total)) 0)
      (if (-> *randomizer-settings* warp-on-yellow-eco?) (the int (-> *game-info* yellow-eco-total)) 0)
      (if (-> *randomizer-settings* warp-on-death?) (the int (-> *game-info* total-deaths)) 0)
      )
   )

  (update-collectable-hud-counters)
  (when (-> *randomizer-settings* use-random-seed?)
    ;; burn through a random number every frame for improved randomness
    (knuth-rand-advance-seed)
  )
)
)
(none))

(defun generateCheckpointList ((seed uint) (length int))
  ;; set the seed which will be used for generating checkpoint list
  (knuth-rand-init (the int64 seed))

  (dotimes (idx length)
    ;; append checkpoint
    (set! (-> *rando-state* checkpoint-list idx)
      (case (-> *randomizer-settings* checkpoint-logic)
        (('logic-random-level)
          ;; choose random level first...
          (let ((random-level-idx (knuth-rand-int-range 0 (-> *checkpoint-list-by-level-idx* length))))
            ;; ...then choose random checkpoint within that level
            (let ((random-level-checkpoint-idx (knuth-rand-int-range 0 (-> *checkpoint-list-by-level-idx* random-level-idx length))))
              (-> *checkpoint-list-by-level-idx*
                random-level-idx
                random-level-checkpoint-idx
                )
              )
            )
          )
        (('logic-random-checkpoint)
          ;; original logic, just choose random checkpoint from list
          (-> *checkpoint-list* (knuth-rand-int-range 0 (-> *checkpoint-list* length)))
          )
        (else
          ;; original logic, just choose random checkpoint from list
          (-> *checkpoint-list* (knuth-rand-int-range 0 (-> *checkpoint-list* length)))
          )
        )
      )
    )
  ;; reset initial index
  (set! (-> *rando-state* next-idx) 0)
  (none)
  )

(defun advanceCheckpointList ((n int))
  (set!
    (-> *rando-state* next-idx)
    (mod (+ (-> *rando-state* next-idx) n) *rando-list-length*)
    )
  )

(defun warpToCheckpoint ((checkpointName string))
  ;; warps to checkpoint, assuming it is already safe to use
  (format 0 "RANDOMIZER: ...warping to ~A~%" checkpointName)
  (set-continue! *game-info* checkpointName)

  ;; trigger death to warp to checkpoint
  ;; this ensures init functions for new level run (misty boat, citadel elevator)
  (initialize! *game-info* 'die (the-as game-save #f) (the-as string #f))
  (none)
  )

(defun checkpointValid? ((checkpointName string))
  (case-str checkpointName
    ;; avoid village1-warp if cutscene tasks not closed
    (("village1-warp")
      (if (or
          (not (task-closed? (game-task intro) (task-status need-resolution)))
          (not (task-closed? (game-task beach-ecorocks) (task-status need-introduction)))
          )
        (return #f)
        )
      )
    )

  ;; additional checkpoints enabled/disabled
  (if (logtest? (-> (get-continue-by-name *game-info* checkpointName) flags) (continue-flags additional-disabled))
    (return #f)
    )

  #t
  )

(defun getNextCheckpoint ()
  (let ((checkpointName (-> *rando-state* checkpoint-list (-> *rando-state* next-idx))))
    (while #t
      ;; increment next-idx
      (advanceCheckpointList 1)

      (when (checkpointValid? (the-as string checkpointName))
        (format 0 "RANDOMIZER: checkpoint ~A is valid~%" checkpointName)
        (return checkpointName) ;; break from while loop
        )

      (format 0 "RANDOMIZER: checkpoint ~A is NOT valid, will grab the next~%" checkpointName)
      (set! checkpointName (-> *rando-state* checkpoint-list (-> *rando-state* next-idx)))
      )
    )
  ""
  )

(defun peekNextCheckpoint ()
  (-> *rando-state* checkpoint-list (-> *rando-state* next-idx))
  )

(defun blacked-out? ()
  ;; if blackout-time is in the future, we're blacked out
  (< (current-time) (-> *game-info* blackout-time))
  )

(defun resetCheckpointRandomizer ()
  ;; (format 0 "RANDOMIZER: resetCheckpointRandomizer!~%")
  (set! (-> *rando-state* collectable-count) 0)

  (when (-> *randomizer-settings* use-random-seed?)
    (set! (-> *randomizer-settings* current-seed) (knuth-rand-next-int))
    )

  ;; reset checkpoint counter backup
  (set! (-> *randomizer-settings* backup-next-idx) 0)

  ;; generate checkpoint list from seed
  (generateCheckpointList (-> *randomizer-settings* current-seed) *rando-list-length*)
  (none)
  )

(defun orchestrateCheckpointWarp ((amount int))
  ;; in case of crash/closed window/etc, generate from last seed and advance checkpoints
  (when (null? (peekNextCheckpoint))
    (format 0 "Regenerating checkpoint list from backup, checkpoints used: ~D~%" (-> *randomizer-settings* backup-next-idx))

    ;; generate checkpoint list from seed
    (generateCheckpointList (-> *randomizer-settings* current-seed) *rando-list-length*)
    (advanceCheckpointList (-> *randomizer-settings* backup-next-idx))
    )

  ;; if blacked out we're already warping, so skip
  (if (not (blacked-out?))
    (begin
      (+! (-> *rando-state* collectable-interval) amount)

      ;; if we're above the collectable threshold, then warp
      (when (>= (-> *rando-state* collectable-interval) (-> *randomizer-settings* collectables-needed-to-warp))
        (format 0 "RANDOMIZER: warping from ~A...~%" (-> *level* level 0 name))
        (warpToCheckpoint (the-as string (getNextCheckpoint)))
        (set! (-> *rando-state* collectable-interval) 0)
        )
      )
    (begin
      (format 0 "RANDOMIZER: skipping collectable/warp as we're already blackout. ~D ~D ~%" (current-time) (-> *game-info* blackout-time))
      )
    )

  ;; update backup-next-idx, commit to file in case of crash/closed window
  (set! (-> *randomizer-settings* backup-next-idx) (-> *rando-state* next-idx))
  (commit-to-file *randomizer-settings*)
  ;;(suspend)
  (none)
  )

(defun checkpointListTest ()
  ;; If we have random-seed on, update our current seed.
  (if (-> *randomizer-settings* use-random-seed?)
    (set! (-> *randomizer-settings* current-seed) (knuth-rand-next-int))
    )
  ;; Generate a list of checkpoints based on our new updated current-seed
  (generateCheckpointList (-> *randomizer-settings* current-seed) *rando-list-length*)
  ;; Print this list of checkpoints to REPL for debugging purposes
  (-> *rando-state* checkpoint-list)
  )

(define *desired-warp-list* (the-as (array string) (new
                                             'static
                                             'boxed-array
                                            ;;  :type string :length 3 :allocated-length 3
                                             :type string :length 72 :allocated-length 72
  "game-start" ;; geyser flies
  "training-far" ;; geyser door
  "training-far" ;; geyser cliff
  "misty-bike" ;; misty boosted
  "misty-bike" ;; misty zoomer
  "misty-silo2" ;; misty ship
  "misty-bike" ;; misty pool
  "misty-start" ;; misty flies
  "misty-silo" ;; misty cannon
  "jungle-tower" ;; jungle switch
  "jungle-start" ;; jungle island
  "jungle-far" ;; jungle door
  "jungle-far" ;; jungle tower
  "jungle-far" ;; jungle flies
  "beach-start" ;; misty muse
  "beach-start" ;; beach gimme
  "beach-pelican" ;; beach cannon
  "beach-pelican" ;; beach pelican
  "beach-far" ;; beach sentinel
  "beach-far" ;; beach harvesters
  "beach-far" ;; beach birds
  "beach-far" ;; beach flies
  "beach-far" ;; beach flut
  "beach-start" ;; sandover mayor
  "village1-far" ;; sandover uncle
  "village1-far" ;; sandover flies
  "firecanyon-start" ;; fc flies
  "village2-warp" ;; fc end
  "rolling-start" ;; basin jump
  "rolling-start" ;; basin flies
  "rolling-start" ;; rv geologist
  "swamp-cave3" ;; swamp tether 4
  "swamp-dock1" ;; swamp tether 1
  "swamp-dock2" ;; swamp tether 2
  "swamp-flutflut" ;; swamp flut
  "swamp-cave2" ;; swamp tether 3
  "sunken1" ;; lpc pipe
  "sunken2" ;; lpc complex
  "sunken2" ;; lpc puzzle
  "sunken-tube1" ;; lpc pool
  "sunken-tube1" ;; lpc piggyback
  "sunken-tube1" ;; lpc chamber
  "sunken-helix" ;; lpc bottom
  "village2-dock" ;; rv gambler
  "village2-dock" ;; rv warrior
  "snow-across-from-flut" ;; snowy switch
  "ogre-end" ;; mp end
  "ogre-race" ;; mp secret
  "ogre-end" ;; mp flies
  "village3-warp" ;; sc platforms
  "maincave-to-darkcave" ;; sc dark cave
  "maincave-to-darkcave" ;; sc crystals
  "robocave-start" ;; sc nest
  "robocave-bottom" ;; sc robot
  "robocave-bottom" ;; sc poles
  "robocave-bottom" ;; sc flies
  "maincave-to-darkcave" ;; crater crate
  "snow-by-ice-lake" ;; snowy crate
  "snow-pass-to-fort" ;; snowy lurker cave
  "snow-pass-to-fort" ;; snowy gate
  "snow-fort" ;; snowy fort
  "snow-start" ;; snowy flies
  "citadel-generator-start" ;; citadel green
  "citadel-generator-end" ;; citadel red
  "citadel-launch-start" ;; citadel yellow
  "citadel-plat-end" ;; citadel blue
  "citadel-start" ;; citadel flies
  "village3-farside" ;; miners
  "village3-farside" ;; miners
  "village3-farside" ;; crater flies
  "lavatube-end" ;; tube end
  "citadel-elevator" ;; FINAL BOSS
  )
  )
  )


(define *desired-warp-list2* (the-as (array string) (new
                                             'static
                                             'boxed-array
                                            ;;  :type string :length 3 :allocated-length 3
                                             :type string :length 72 :allocated-length 72
  "game-start" ;; geyser flies
  "training-far" ;; geyser door
  "training-far" ;; geyser cliff
  "misty-bike" ;; misty boosted
  "misty-bike" ;; misty zoomer
  "misty-silo2" ;; misty ship
  "misty-bike" ;; misty pool
  "misty-start" ;; misty flies
  "misty-silo" ;; misty cannon
  "jungle-tower" ;; jungle switch
  "jungle-start" ;; jungle island
  "jungle-far" ;; jungle door
  "jungle-far" ;; jungle tower
  "jungle-far" ;; jungle flies
  "beach-start" ;; misty muse
  "beach-start" ;; beach gimme
  "beach-pelican" ;; beach cannon
  "beach-pelican" ;; beach pelican
  "beach-far" ;; beach sentinel
  "beach-far" ;; beach harvesters
  "beach-far" ;; beach birds
  "beach-far" ;; beach flies
  "beach-far" ;; beach flut
  "beach-start" ;; sandover mayor
  "village1-far" ;; sandover uncle
  "village1-far" ;; sandover flies
  "firecanyon-start" ;; fc flies
  "firecanyon-end" ;; fc end
  "village2-warp" ;; rv warrior
  "village2-start" ;; basin jump
  "rolling-start" ;; basin flies
  "rolling-start" ;; rv geologist
  "swamp-start" ;; swamp tether 4
  "swamp-dock1" ;; swamp tether 1
  "swamp-dock2" ;; swamp tether 2
  "swamp-flutflut" ;; swamp flut
  "swamp-cave2" ;; swamp tether 3
  "sunken1" ;; lpc pipe
  "sunken2" ;; lpc complex
  "sunken2" ;; lpc puzzle
  "sunken-tube1" ;; lpc pool
  "sunken-tube1" ;; lpc piggyback
  "sunken-tube1" ;; lpc chamber
  "sunken-helix" ;; lpc bottom
  "village2-dock" ;; rv gambler
  "village2-dock" ;; rv flies
  "snow-across-from-flut" ;; snowy switch
  "ogre-end" ;; mp end
  "ogre-race" ;; mp secret
  "ogre-end" ;; mp flies
  "village3-warp" ;; sc platforms
  "robocave-start" ;; sc nest
  "robocave-bottom" ;; sc robot
  "robocave-bottom" ;; sc poles
  "maincave-to-darkcave" ;; crater crate
  "snow-by-ice-lake" ;; snowy crate
  "snow-pass-to-fort" ;; snowy lurker cave
  "snow-outside-fort" ;; snowy gate
  "snow-fort" ;; snowy fort
  "snow-start" ;; snowy flies
  "citadel-generator-start" ;; citadel green
  "citadel-generator-end" ;; citadel red
  "citadel-launch-start" ;; citadel yellow
  "citadel-plat-end" ;; citadel blue
  "citadel-start" ;; citadel flies
  "village3-farside" ;; miners
  "village3-farside" ;; miners
  "village3-farside" ;; miners
  "village3-farside" ;; miners
  "village3-farside" ;; crater flies
  "lavatube-end" ;; tube end
  "citadel-elevator" ;; FINAL BOSS
  )
  )
  )

(defun find-desired-seed ()
  (process-spawn-function process
    :name 'find-desired-seed-proc
    :to *active-pool*
    ;This lambda is our function
    (lambda :behavior process ()
      (stack-size-set! (-> self main-thread) 2048)
      (let ((best 0)
            (best-seed (the uint 0))
            (best-with-cita-end 0)
            (best-seed-with-cita-end (the uint 0))
            (counter 0)
            )
        (while #t
          (let ((used1 (new 'stack-no-clear 'array 'symbol 72))
                (tmp1 0)
                (used2 (new 'stack-no-clear 'array 'symbol 72))
                (tmp2 0)
                )
            (dotimes (j (length *desired-warp-list*))
              (set! (-> used1 j) #f)
              (set! (-> used2 j) #f)
              )
            
            (+! counter 1)
            (when (> counter 100)
              (set! counter 0)
              (suspend) ;; let the MFer breathe
              )
            (resetCheckpointRandomizer)
            ;; (format 0 "trying seed ~D~%" (-> *randomizer-settings* current-seed))

            ;; see if list matches
            (dotimes (i (length *desired-warp-list*)) ;; loop thru first X rando-state checkpoint-list warps and see how many we wanted
              (dotimes (j (length *desired-warp-list*)) ;; loop thru desired list to find unused match
                (when (and (not (-> used1 j)) (string= (-> *desired-warp-list* j) (-> *rando-state* checkpoint-list i)))
                  (true! (-> used1 j))
                  (+! tmp1 1)
                  (set! j (length *desired-warp-list*))
                  ;; (format 0 "   list1 wanted ~S, so far matches ~D ~%" (-> *desired-warp-list* j) tmp1)
                  )
                )
              (dotimes (j (length *desired-warp-list*)) ;; loop thru desired list to find unused match
                (when (and (not (-> used2 j)) (string= (-> *desired-warp-list2* j) (-> *rando-state* checkpoint-list i)))
                  (true! (-> used2 j))
                  (+! tmp2 1)
                  (set! j (length *desired-warp-list*))
                  ;; (format 0 "   list2 wanted ~S, so far matches ~D ~%" (-> *desired-warp-list2* j) tmp2)
                  )
                )
              )
            
            (when (string= (-> *rando-state* checkpoint-list 71) "citadel-elevator")
              (when (< best-with-cita-end tmp1)
                (set! best-with-cita-end tmp1)
                (set! best-seed-with-cita-end (-> *randomizer-settings* current-seed))
                (format 0 "New best seed with citadel-elevator end, matched ~D/72 desired warps: ~D ~%" best-with-cita-end best-seed-with-cita-end)
                )
              (when (< best-with-cita-end tmp2)
                (set! best-with-cita-end tmp2)
                (set! best-seed-with-cita-end (-> *randomizer-settings* current-seed))
                (format 0 "New best seed with citadel-elevator end, matched ~D/72 desired warps: ~D ~%" best-with-cita-end best-seed-with-cita-end)
                )
              )
            
            (when (< best tmp1)
              (set! best tmp1)
              (set! best-seed (-> *randomizer-settings* current-seed))
              (format 0 "New best seed, matched ~D/72 desired warps: ~D ~%" best best-seed)
              )
            (when (< best tmp2)
              (set! best tmp2)
              (set! best-seed (-> *randomizer-settings* current-seed))
              (format 0 "New best seed, matched ~D/72 desired warps: ~D ~%" best best-seed)
              )
            )
          )
        )
      )
    )
  (none)
  )